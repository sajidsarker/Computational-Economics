def value_fn_engine(epsilon, max_iter, beta, theta):

    x_t = np.linspace(0, 10, 11)

    dif = 1e5

    iterNum = 0

    P = [0.2, 0.8]

    P = diags(P, np.arange(2), shape=(11, 11)).todense()

    P = P.T

    P[10, 10] = 1

    new_value_flat = np.ones((1, 11), dtype=np.float128) - 10 #[0, 0] is after replacement

    old_vf = new_value_flat

    EV = np.zeros(11)

    mu = 0.5772

    while iterNum < max_iter and dif > epsilon:

        EV = EV.reshape(1, 11)


        a = EV[0, 10].reshape(1, 1)

        b = EV[0, 1:11].reshape(1, 10)


        EV_long = np.concatenate((b, a), axis=1)


        if np.max(utility_engine(theta=theta, i=1, x_t=x_t) + beta * old_vf[0,0]) > 500:

            break

        # RUST METHOD (really close to right) Choice Specific

        # new_value_flat = mu + np.log(np.exp(utility_engine(theta=theta, i=0, x_t=x_t) + beta * (0.2 * old_vf + 0.8 * EV_long) + \

        # np.exp(utility_engine(theta=theta, i=1, x_t=x_t) + beta * (0.2*old_vf[0,0] + 0.8*old_vf[0,1])))) * P


        new_value_flat = (mu + np.log(np.exp(utility_engine(theta=theta, i=0, x_t=x_t) + beta * old_vf) +

                          np.exp(utility_engine(theta=theta, i=1, x_t=x_t) + beta * old_vf[0,0]))) * P


        # a = (np.log(np.exp(utility_engine(theta=theta, i=0, x_t=x_t) + beta * old_vf) +

        #                   np.exp(utility_engine(theta=theta, i=1, x_t=x_t) + beta * old_vf[0,0])))

        # new_value_flat = P.T.dot(a.T).reshape(1, 11)

        # print(P.shape, a.shape, new_value_flat.shape)


        iterNum += 1

        dif = np.linalg.norm(new_value_flat - old_vf)

        old_vf = new_value_flat

        EV = new_value_flat


    return EV, iterNum, dif


def log_lik(theta, EV, beta, lam, mileage, replacement):

    ll = 0

    for i in range(1, 5000):

        delta_mileage = mileage[i] - mileage[i - 1]

        if delta_mileage == 1 and replacement[i - 1] == 0:

            prob_mileage = lam

        elif delta_mileage == 0 and replacement[i - 1] == 0:

            prob_mileage = 1 - lam

        elif delta_mileage == 1 and replacement[i - 1] == 1:

            prob_mileage = lam

        elif mileage[i] == 0:

            prob_mileage = 1 - lam

        elif mileage[i] == 1 and replacement[i - 1] == 1:

            prob_mileage = lam


        else:

            print("Weird mileage transition occured")

            print(mileage[i], delta_mileage, replacement[i])


        x_t = int(mileage[i])

        prob_rep = prob_replace(EV=EV, theta=theta, beta=beta)

        prob_rep_xt = prob_rep[0, x_t]


        if replacement[i] == 1:

            prob_rep_engine = prob_rep_xt

        elif replacement[i] == 0:

            prob_rep_engine = 1 - prob_rep_xt

        else:

            print("Error in rep_prob")


        if prob_rep_engine <= 0 or prob_mileage <= 0:

            print(prob_rep_engine, prob_mileage)


        if prob_rep_engine <= 0:

            prob_rep_engine = 0.0001

            print("Warning, prob_rep_engine set incorrectly")


        ll_temp = np.log(prob_rep_engine) + np.log(prob_mileage)

        ll += ll_temp

    return -ll


def prob_replace(EV, theta, beta):

    x_t = np.linspace(0, 10, 11).astype(int) # initialize bus, START 'ER UP

    EV = EV.reshape(1, 11)


    a = EV[0,10].reshape(1,1)


    EV_long = np.concatenate((EV, a), axis=1)


    # V1 = np.exp(utility_engine(theta, i=1, x_t=x_t) + beta * (0.2 * EV[0, 0] + 0.8 * EV[0, 1]))

    # V0 = np.exp(utility_engine(theta, i=0, x_t=x_t) + beta * (0.2 * EV[0, x_t] + 0.8 * EV_long[0, x_t+1]))


    V1 = np.exp(utility_engine(theta, i=1, x_t=x_t) + beta * EV[0, 0])

    V0 = np.exp(utility_engine(theta, i=0, x_t=x_t) + beta * EV[0, x_t])


    return V1 / (V1 + V0)



# Simulate data

# gum = np.random.gumbel(0, 1, 200000). reshape(100000, 2)

real_theta = [0.3, 0.0, 4.0]

# EV = value_fn_engine(epsilon=1e-12, max_iter=1000, beta=0.95, theta=[0.3, 0.0, 4.0])[0]

s_data = sim_data(5000, draws=draws, theta=[0.3, 0.0, 4.0], EV=EV, beta=0.95)[1]

replacement = s_data[:, 0]

mileage = s_data[:, 1]

i = 0


def run_rust(theta, beta, lam, replacement, mileage):

    # Get EVs

    EV = value_fn_engine(epsilon=1e-10, max_iter=1000, beta=beta, theta=theta)[0]


    # Get log-likelihood

    ll = log_lik(theta=theta, EV=EV, beta=beta, lam=lam, mileage=mileage, replacement=replacement)

    print("One Loop")

    print(theta)

    print(ll)


    return ll



theta_init = [0.3, 0.0, 4.0]


start = time.clock()


MLE = minimize(run_rust, theta_init, method='BFGS', args=(0.95, 0.8, replacement, mileage)) #BFGS seems faster

print(MLE)
